<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo + Webhooks 部署至阿里云]]></title>
    <url>%2F2020%2F04%2F05%2FHexo%20%2B%20Webhooks%20%E9%83%A8%E7%BD%B2%E8%87%B3%E9%98%BF%E9%87%8C%E4%BA%91%2F</url>
    <content type="text"><![CDATA[解决了 Hexo 部署在 GitHub Pages 时解析龟速的尴尬问题。 绑定至主站下的二级域名 hexo.macrohard.cn，等待 SSL 证书生效。]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的 Typecho 博客正式上线]]></title>
    <url>%2F2019%2F11%2F28%2F%E6%88%91%E7%9A%84%20Typecho%20%E5%8D%9A%E5%AE%A2%E6%AD%A3%E5%BC%8F%E4%B8%8A%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[前后提交了三次申请、耗时两周，网站域名备案总算通过了。至此，我的Typecho博客正式上线。 没有打算把所有感想记录于此，计划每个阶段想一点写一点。 大一时开通过CSDN博客，也鼓捣过Hexo，在此简要叙述一下个人的体验感受。 CSDN博客具有易于操作的在线文本编辑器，支持Markdown、Mathjax等等。进行新增文章、分类等管理操作十分方便，还具有良好的SEO（不信你在百度搜索 sduwh ）。 但它的缺陷明显：广告太多，可塑性几乎没有。 Hexo是一款快速、简洁且高效的博客框架，通过Node.js框架快速渲染页面，再一键远程部署到GitHub、Coding等代码托管平台。它支持Markdown的所有功能，可以整合大量插件，可拓展性max。 此外，因为它可部署到代码托管平台呈现静态页面，所以不依赖于服务器，对比WordPress等可节省一笔开销。 缺点也有：由于所有的维护、管理操作都是在本地命令行或文件中进行的，所以在配置博客外观细节的过程中，没有经验的童鞋会被弄得晕头转向，它更适合有Web开发技术的童鞋玩耍。博客中的图片资源通常通过GitHub或图床存储，加载缓慢（简直龟速==）。 就个人而言，我更偏好采用Hexo一类的框架搭建博客，最重要的原因就是能够在实践中学习。 这次采用Typecho，是在参观PasteMe项目作者Lucien姐姐的博客之后决定的。 当时发现阿里云服务器学生套餐仅需110+r/y，就毫不犹豫地下单了。 Typecho与WordPress相似，但更加轻量。通过采用社区dalao写好的主题，可以在人性化的外观管理页面下配置外观，也能够像Hexo那样通过修改配置文件实现高度自定义。 总而言之，在我看来Typecho弥补了Hexo博客网站解析和图片加载速度慢的缺陷，管理方便也不失可塑性，爱了爱了。]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>Typecho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 2019 CCPC Qinhuangdao Onsite J. MUV LUV EXTRA]]></title>
    <url>%2F2019%2F11%2F24%2F%E9%A2%98%E8%A7%A3-2019-CCPC-Qinhuangdao-Onsite-J-MUV-LUV-EXTRA%2F</url>
    <content type="text"><![CDATA[观察样例不难发现，在最优解中，p为后缀循环节出现的总长度（可能包含不完整循环节），l为后缀最小循环节长度。 将序列逆序后枚举前缀，则p == i, l == i - next[i]，维护上式最大值即为答案。 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int inf = 0x3f3f3f3f; const int maxn = 1e7 + 10; int num[maxn], nxt[maxn]; char s[maxn]; inline const int read() { int x = 0, f = 1; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) { if (ch == &#39;-&#39;) f = -1; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - &#39;0&#39;; ch = getchar(); } return x * f; } void getNext(int* v, int n) { for (int i = 2, j = 0; i &lt;= n; i++) { while (j &amp;&amp; v[i] != v[j + 1]) j = nxt[j]; if (v[i] == v[j + 1]) j++; nxt[i] = j; } } int main() { int len = 0; ll a = read(), b = read(), ans = -inf; scanf(&quot;%s&quot;, s); for (int i = (int)strlen(s) - 1; s[i] != &#39;.&#39;; i--) num[++len] = s[i] - &#39;0&#39;; getNext(num, len); for (int i = 1; i &lt;= len; i++) ans = max(ans, i * a - (i - nxt[i]) * b); printf(&quot;%lld\n&quot;, ans); return 0; }]]></content>
      <tags>
        <tag>最小循环节</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 2018 ICPC Asia Nanjing Onsite I. Magic Potion]]></title>
    <url>%2F2019%2F11%2F21%2F%E9%A2%98%E8%A7%A3-2018-ICPC-Asia-Nanjing-Onsite-I-Magic-Potion%2F</url>
    <content type="text"><![CDATA[Magic PotionPortal1 Portal2 There are n heroes and mm monsters living in an island. The monsters became very vicious these days, so the heroes decided to diminish the monsters in the island. However, the i-th hero can only kill one monster belonging to the set Mi​. Joe, the strategist, has k bottles of magic potion, each of which can buff one hero’s power and let him be able to kill one more monster. Since the potion is very powerful, a hero can only take at most one bottle of potion. Please help Joe find out the maximum number of monsters that can be killed by the heroes if he uses the optimal strategy. InputThe first line contains three integers n,m,k (1≤n,m,k≤500) —— the number of heroes, the number of monsters and the number of bottles of potion. Each of the next n lines contains one integer ti​, the size of Mi​, and the following ti​ integers Mi,j​ (1≤j≤ti​), the indices (1-based) of monsters that can be killed by the i-th hero (1≤ti​≤m,1≤Mi,j​≤m). OutputPrint the maximum number of monsters that can be killed by the heroes. 样例输入13 5 2 4 1 2 3 5 2 2 5 2 1 2样例输出14样例输入25 10 2 2 3 10 5 1 3 4 6 10 5 3 4 6 8 9 3 1 9 10 5 1 3 6 7 10样例输出27题目来源ACM-ICPC Nanjing Onsite 2018 题解这两天认真看了看网络流，时隔一个月补题。 建图如下： #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 1e6 + 10; const int maxm = 1e6 + 10; const int inf = 0x3f3f3f3f; int cnt, head[maxn], dep[maxn], cur[maxn]; struct edge { int to, flow, next; } e[maxm]; inline const int read() { int x = 0, f = 1; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) { if (ch == &#39;-&#39;) f = -1; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - &#39;0&#39;; ch = getchar(); } return x * f; } void addEdge(int u, int v, int w) { e[cnt].to = v; e[cnt].flow = w; e[cnt].next = head[u]; head[u] = cnt++; } bool bfs(int s, int t) { queue&lt;int&gt; q; memset(dep, -1, sizeof(dep)); dep[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (dep[v] == -1 &amp;&amp; e[i].flow) { q.push(v); dep[v] = dep[u] + 1; } } } return ~dep[t]; } int dfs(int u, int t, int rflow) { if (u == t) return rflow; int res = 0; for (int i = cur[u]; ~i &amp;&amp; rflow; i = e[i].next) { int v = e[i].to; if (dep[v] != dep[u] + 1 || !e[i].flow) continue; cur[u] = i; int flow = dfs(v, t, min(e[i].flow, rflow)); e[i].flow -= flow; e[i ^ 1].flow += flow; rflow -= flow; res += flow; } if (!res) dep[u] = -1; return res; } int dinic(int s, int t) { int res = 0; while (bfs(s, t)) { memcpy(cur, head, sizeof(head)); res += dfs(s, t, inf); } return res; } int main() { int n = read(), m = read(), k = read(); memset(head, -1, sizeof(head)); addEdge(n + m + 2, n + m + 1, k); addEdge(n + m + 1, n + m + 2, 0); for (int i = 1; i &lt;= n; i++) { addEdge(n + m + 2, i, 1); addEdge(i, n + m + 2, 0); addEdge(n + m + 1, i, 1); addEdge(i, n + m + 1, 0); int t = read(); while (t--) { int j = read(); addEdge(i, n + j, 1); addEdge(n + j, i, 0); } } for (int i = n + 1; i &lt;= n + m; i++) { addEdge(i, n + m + 3, 1); addEdge(n + m + 3, i, 0); } printf(&quot;%d\n&quot;, dinic(n + m + 2, n + m + 3)); return 0; }]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 The Preliminary Contest for ICPC Asia Nanjing 2019 A. The beautiful values of the palace]]></title>
    <url>%2F2019%2F11%2F21%2F%E9%A2%98%E8%A7%A3-The-Preliminary-Contest-for-ICPC-Asia-Nanjing-2019-A-The-beautiful-values-of-the-palace%2F</url>
    <content type="text"><![CDATA[Here is a square matrix of n n, each lattice has its value (n must be odd), and the center value is n n. Its spiral decline along the center of the square matrix (the way of spiral decline is shown in the following figure:)The grid in the lower left corner is (1,1) and the grid in the upper right corner is (n , n) Now I can choose m squares to build palaces. The beauty of each palace is equal to the digital sum of the value of the land which it is located. Such as (the land value is 123213, the beautiful values of the palace located on it is 1 + 2 + 3 + 2 + 1 + 3 = 12) ( 666 666 -&gt; 18 18) ( 456 456 -&gt; 15 15). Next, we ask p times to the sum of the beautiful values of the palace in the matrix where the lower left grid (x1, y1), the upper right square (x2, y2). InputThe first line has only one number T. Representing T-group of test data (T ≤ 5) The next line is three number: n m p The m lines follow, each line contains two integers the square of the palace (x, y) The p lines follow, each line contains four integers: the lower left grid (x1, y1), the upper right square (x2, y2) OutputNext, p1 + p2 … + pT lines: Represent the answer in turn. (n ≤ 10 ^ 6) (m, p ≤ 10 ^ 5) (n ≤ 10 ^ 6) (m, p ≤ 10 ^ 5) 样例输入 1 3 4 4 1 1 2 2 3 3 2 3 1 1 1 1 2 2 3 3 1 1 3 3 1 2 2 3样例输出 5 18 23 17Solution这是刚开学时南京站网络赛的一道题，当时是在学长的指导下写的。现场赛打铁后再来重温一下。 题目大意：给定一个大小为n * n，元素值从1开始自右上角顺时针螺旋递增的矩阵，查询在指定矩形范围内所有值的各位数之和。 这是二维扫描线，官方题解方法是离散化 + 二维前缀和，我的方法是离散化 + 线段树 + 离线操作。 将所有值所在的点坐标和所有查询的点坐标存入结构体按照位置和种类排序后，当遍历到某一次查询的左下角点时，利用线段树求在此查询左右范围内的和，当遍历到此次查询的右上角点时，再重复一次操作，两个和作差即此次查询的结果。 难点在于构造螺旋矩阵坐标对值的映射和定义所有点坐标的排序规则，具体代码实现如下。 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 1e6 + 10; const int maxm = 1e5 + 10; int t, n, m, p, cnt, ans[maxm]; struct node { int l, r, sum; } tree[maxn &lt;&lt; 2]; struct cor { int x, y, type, qid; } cord[maxm &lt;&lt; 2]; struct qes { int x1, x2; } qest[maxm]; // type == 0: square for update, type == 1: lower left square for query, type == 2: upper right square for query inline const int read() { int x = 0, f = 1; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) { if (ch == &#39;-&#39;) f = -1; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - &#39;0&#39;; ch = getchar(); } return x * f; } int getVal(ll x, ll y) { x = x - n / 2 - 1; y = y - n / 2 - 1; ll tmp = max(abs(x), abs(y)); ll num = x &gt;= y ? (ll)n * n - tmp * tmp * 4 - tmp * 2 - x - y : (ll)n * n - tmp * tmp * 4 + tmp * 2 + x + y; int res = 0; do { res += num % 10; num /= 10; } while (num); return res; } bool cmp(const cor &amp;a, const cor &amp;b) { if (a.y != b.y) return a.y &lt; b.y; if (a.x != b.x) return a.x &lt; b.x; if ((a.type == 0 &amp;&amp; b.type == 1) || (a.type == 1 &amp;&amp; b.type == 0)) return a.type &gt; b.type; return a.type &lt; b.type; } inline int ls(int id) {return id &lt;&lt; 1;} inline int rs(int id) {return id &lt;&lt; 1 | 1;} void push_up(int id) { tree[id].sum = tree[ls(id)].sum + tree[rs(id)].sum; } void build(int id, int l, int r) { tree[id].l = l; tree[id].r = r; tree[id].sum = 0; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(ls(id), l, mid); build(rs(id), mid + 1, r); push_up(id); } void update(int id, int l, int r, int v) { if (tree[id].l == l &amp;&amp; tree[id].r == r) { tree[id].sum += (r - l + 1) * v; return; } int mid = (tree[id].l + tree[id].r) &gt;&gt; 1; if (r &lt;= mid) update(ls(id), l, r, v); else if (l &gt; mid) update(rs(id), l, r, v); else { update(ls(id), l, mid, v); update(rs(id), mid + 1, r, v); } push_up(id); } int query(int id, int l, int r) { if (tree[id].l == l &amp;&amp; tree[id].r == r) return tree[id].sum; int mid = (tree[id].l + tree[id].r) &gt;&gt; 1; if (r &lt;= mid) return query(ls(id), l, r); if (l &gt; mid) return query(rs(id), l, r); return query(ls(id), l, mid) + query(rs(id), mid + 1, r); } int main() { t = read(); while (t--) { cnt = 0; n = read(); m = read(); p = read(); build(1, 1, n); for (int i = 0; i &lt; m; i++) { int x = read(), y = read(); cord[cnt++] = cor{x, y, 0, 0}; } for (int i = 0; i &lt; p; i++) { int x1 = read(), y1 = read(), x2 = read(), y2 = read(); cord[cnt++] = cor{x1, y1, 1, i}; cord[cnt++] = cor{x2, y2, 2, i}; qest[i] = qes{x1, x2}; } sort(cord, cord + cnt, cmp); for (int i = 0; i &lt; cnt; i++) { int x = cord[i].x, y = cord[i].y, id = cord[i].qid; if (cord[i].type == 0) update(1, x, x, getVal(x, y)); else if (cord[i].type == 1) ans[id] = query(1, qest[id].x1, qest[id].x2); else ans[id] = query(1, qest[id].x1, qest[id].x2) - ans[id]; } for (int i = 0; i &lt; p; i++) printf(&quot;%d\n&quot;, ans[i]); } return 0; }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时隔两个月发布新博客]]></title>
    <url>%2F2019%2F10%2F23%2F%E6%97%B6%E9%9A%94%E4%B8%A4%E4%B8%AA%E6%9C%88%E5%8F%91%E5%B8%83%E6%96%B0%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这个周末就要去南京参加第一次区域赛，为了平复激动的心情才来博客里唠嗑一下。 开学以来忙忙碌碌，难以顾及博客的维护更新。 只做了一点小小的改动，修复了Prettify代码高亮JS的一个小BUG： 代码过长时没有水平滚动条而是直接换行，影响阅读体验。 此外我尝试了Hanabi，这也是Material主题内置的代码高亮插件之一，我很喜欢它的配色。 美中不足是它无法解析”&amp;”运算符，在代码块中会显示成转义字符&amp;amp;。 后来在Material主题的代码仓库Issues里意外地发现曾经有人提出了相同的问题（包括Prettify增加水平滚动条）。 根据社区dalao提供的解决方案调试一波之后修复了Hanabi字符解析问题，但它还存在一个致命BUG：代码行数过多时显示不全。遂放弃Hanabi重用Prettify。 一个多月前得知要参加10月底的区域赛，之后包括国庆假期在内的每周都做了3-4场训练赛。 这次比赛队友涵哥不参加，袁老师给我们安排了一位大三学长做队友。学长不仅ACM👍，还是个学霸。 庄大仙也很🐂，CF持续上分，已经突破蓝名了。 还天天装弱，真是可恶啊:( 自从暑假以来我的状态就一直低迷，之前立的flag也忘了。 现在常常觉得时间不够用。日子一天天过去，学校课程我没有好好学，ACM也还是那么菜。 好多好多需要学习的数据结构和算法在To do清单里等着我，也许要等鸡吃完了米、狗舔完了面、我睡足了觉。 都是瞎熬夜惹的祸，叹气Orz。 最后希望不要打铁，虽然八成没戏。嗯就这样。]]></content>
      <categories>
        <category>Daily</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解 洛谷P4980 【模板】Polya定理]]></title>
    <url>%2F2019%2F08%2F28%2F%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7P4980-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91Polya%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[题目描述给定一个n个点，n条边的环，有n种颜色，给每个顶点染色，问有多少种本质不同的染色方案，答案对10^9+7取模 注意本题的本质不同，定义为：只需要不能通过旋转与别的染色方案相同。 输入格式第一行输入一个t，表示有t组数据 第二行开始，一共t行，每行一个整数n，意思如题所示。 输出格式共t行，每行一个数字，表示染色方案数对10^9+7取模后的结果 输入输出样例输入 #1 5 1 2 3 4 5 输出 #1 1 3 11 70 629说明/提示n≤10^9 t≤10^3 题解根据Polya定理易知答案为 $\frac{1}{n}\sum_{i=1}^{n}n^{gcd\left(i,n\right)}$ 。 考虑优化：设g(i)为gcd(i, n)，显然所有的g都是n的因数，故可枚举n的因数。 当枚举到n的第i个因数时，总存在 $g=\frac{n}{p_{i}}$ 。 设有x个g值相同，不难发现 $x=\varphi\left(\frac{n}{g}\right)=\varphi\left(p\right)$ 。 故答案可化简： $\frac{1}{n}\sum_{i=1}^{n}n^{gcd\left(i,n\right)}=\frac{1}{n}\sum_{p|n}\varphi \left(p\right)\cdot n^{\frac{n}{p}}=\sum_{p|n}\varphi \left(p\right)\cdot n^{\frac{n}{p}-1}$ 。 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod = 1e9 + 7; inline const int read() { int x = 0, f = 1; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) { if (ch == &#39;-&#39;) f = -1; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - &#39;0&#39;; ch = getchar(); } return x * f; } ll quick_pow(ll x, ll n) { ll res = 1; while (n) { if (n &amp; 1) res = res * x % mod; n &gt;&gt;= 1; x = x * x % mod; } return res; } ll euler(int n) { ll res = 1; for (int i = 2; i &lt;= sqrt(n); i++) { if (n % i == 0) { n /= i; res *= i - 1; while (n % i == 0) { n /= i; res *= i; } } } if (n &gt; 1) res *= n - 1; return res; } ll polya(int n) { ll res = 0; for (int i = 1; i &lt;= sqrt(n); i++) if (n % i == 0) res = i * i == n ? (res + euler(i) * quick_pow(n, n / i - 1)) % mod : (res + euler(i) * quick_pow(n, n / i - 1) + euler(n / i) * quick_pow(n, i - 1)) % mod; return res; } int main() { int t = read(); while (t--) { int n = read(); printf(&quot;%lld\n&quot;, polya(n)); } return 0; }]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>组合数学</tag>
        <tag>Polya定理</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 Gym101873B Buildings]]></title>
    <url>%2F2019%2F08%2F26%2F%E9%A2%98%E8%A7%A3-Gym101873B-Buildings%2F</url>
    <content type="text"><![CDATA[题目描述As a traveling salesman in a globalized world, Alan has always moved a lot. He almost never lived in the same town for more than a few years until his heart yearned for a different place. However, this newest town is his favorite yet - it is just so colorful. Alan has recently moved to Colorville, a smallish city in between some really nice mountains. Here, Alan has finally decided to settle down and build himself a home - a nice big house to call his own. In Colorville, many people have their own houses - each painted with a distinct pattern of colors such that no two houses look the same. Every wall consists of exactly n × n squares, each painted with a given color (windows and doors are also seen as unique “colors”). The walls of the houses are arranged in the shape of a regular m-gon, with a roof on top. According to the deep traditions of Colorville, the roofs should show the unity among Colorvillians, so all roofs in Colorville have the same color. Of course, Alan wants to follow this custom to make sure he fits right in. However, there are so many possible designs to choose from. Can you tell Alan how many possible house designs there are? (Two house designs are obviously the same if they can be translated into each other just by rotation.) 输入The input consists of:• one line with three integers n, m, and c, where– n (1 ≤ n ≤ 500) is the side length of every wall, i.e. every wall consists of n × n squares;– m (3 ≤ m ≤ 500) is the number of corners of the regular polygon;– c (1 ≤ c ≤ 500) the number of different colors. 输出Output s where s is the number of possible different house designs. Since s can be very large, output s mod (10 ^ 9 + 7). 样例输入1 3 1样例输出1题解这是一道经典的手镯问题，可转化为“用c^(n^2)种不同颜色的珠子穿成有m颗珠子的手镯，有多少种方案”。 由组合数学Polya定理易知答案为 $\frac{1}{m}\sum_{i=1}^{m}c^{n^{2}\cdot gcd(i,m)}$。由于求和过程涉及模运算，最后需要计算m的乘法逆元。 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod = 1e9 + 7; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } ll quick_pow(ll x, ll n) { ll res = 1; while (n) { if (n &amp; 1) res = res * x % mod; n &gt;&gt;= 1; x = x * x % mod; } return res; } int main() { int n, m, c; ll ans = 0; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;c); for (int i = 1; i &lt;= m; i++) ans = (ans + quick_pow(c, n * n * gcd(i, m))) % mod; ans = ans * quick_pow(m, mod - 2) % mod; printf(&quot;%lld\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>Polya定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Polya定理]]></title>
    <url>%2F2019%2F08%2F26%2FPolya%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[Polya定理 本文转载自 博客园 Burnside和Polya定理都是高级计数的工具。对于一般计数问题，可以用排列组合来统计，但是对于更复杂的问题，比如对n个点用m种颜色染色，并且认为这n个点可以相互转移，即第一个点的位置可以与第二个点互换等等，求最多有多少种不同的染色（两种染色不同，当且仅当两者在空间上存在相同位置的两点颜色，且无法通过允许的转移从前者转移到后者）。 组合数学提供了强悍的Burnside和Polya定理来对这种复杂情况的可能数进行计数。 基础知识我们将允许的转移以下列方程表示出来： (1 2 3 4 5) (2 3 4 5 1) 对于任意输入值，我们先在上面方框里找到对应的下标（如果值未上方标识出来，那么返回值就是输入值，即等值转换），并用该下标在下面方框里找到映射值。实际上可以发现置换是一个函数，因为每个输入值通过转移可以转换为另外一个确定的值。 对于定义域和值域均落在集合V上的所有置换的集合，称为V上的置换类。（事实上这个类是一个群，但是我们不细讲） 可以发现上面的输入值x转移得到的值均为上方括号该值出现的后一位（最后一位后面就认为是首位），其构成了一个循环，我们用(1 2 3 4 5)来简单标记，称这样的置换为循环。 由于置换是函数，因此我们可以进行复合操作，即对于置换f与g，我们记fg为二者的复合函数（转移），而(fg)(x)=f(g(x))。若f与g是循环，其也可以写作(f1 f2 … fn)(g1 g2 … gm)。 定理：任意一个置换都可以拆解成为若干个不相交循环。比如(1 2 3)(4 5)等价于下面的置换： (1 2 3 4 5) (2 3 1 5 4) 对于指定值x，若置换f满足f(x)=x，那么称f是x不动置换，相应的称x是f的不动点，由所有x的不动置换组成的集合称为x不动置换类。 置换可以直接作用于向量，对于向量(a1,a2,…,an)，我们记f(a1,a2,…,an)=(af(1),af(2),…,af(n))。 核心定理现在来描述问题。有n个点和m种颜色，问有多少种不同的染色的可能。并且提供一个[1,n]上的置换类G，当且仅当两个染色方案a与b，对于所有G中的置换g，都满足g(a)&lt;&gt;b，才认为两个染色方案不同。而每个染色方案可以用向量来表示(c1,c2,…,cn)。其中ci表示第i个点所上的颜色。并且我们称相同的染色方案（向量）为等价类。 Polya定理：记置换G={a1,…,ak}，在[1,m]^n上，不同的向量数目 $L=\frac{1}{\left|G\right|}\sum_{i=1}^{k} m^{l(a_{i})}$ 。其中l(ai)表示置换ai可以展开为循环的节数，比如(1 2)(3 4)(5)就是3节循环。 注意使用这两个定理，要保证G中不含重复的置换。（两个置换相同与函数相同的定义一致）。]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>组合数学</tag>
        <tag>Polya定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 POJ2528 / UVA10587 Mayor's posters]]></title>
    <url>%2F2019%2F08%2F15%2F%E9%A2%98%E8%A7%A3-POJ2528-UVA10587-Mayor-s-posters%2F</url>
    <content type="text"><![CDATA[// Version 1 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 1e4 + 10; int id[maxn &lt;&lt; 2]; bool vis[maxn]; struct intvl { int l, r; } itv[maxn]; struct node { int l, r, v; } tree[maxn &lt;&lt; 4]; inline const int read() { int x = 0, f = 1; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) { if (ch == &#39;-&#39;) f = -1; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - &#39;0&#39;; ch = getchar(); } return x * f; } inline int ls(int id) { return id &lt;&lt; 1; } inline int rs(int id) { return id &lt;&lt; 1 | 1; } void push_up(int id) { if (tree[ls(id)].v == tree[rs(id)].v) tree[id].v = tree[ls(id)].v; else tree[id].v = 0; } void push_down(int id) { if (tree[id].v) tree[ls(id)].v = tree[rs(id)].v = tree[id].v; } void build(int id, int l, int r) { if ((tree[id].l = l) == (tree[id].r = r)) { tree[id].v = 0; return; } int mid = (l + r) &gt;&gt; 1; build(ls(id), l, mid); build(rs(id), mid + 1, r); } void update(int id, int l, int r, int v) { if (tree[id].l == l &amp;&amp; tree[id].r == r) { tree[id].v = v; return; } push_down(id); int mid = (tree[id].l + tree[id].r) &gt;&gt; 1; if (r &lt;= mid) update(ls(id), l, r, v); else if (l &gt; mid) update(rs(id), l, r, v); else { update(ls(id), l, mid, v); update(rs(id), mid + 1, r, v); } push_up(id); } int query(int id, int l, int r) { if (tree[id].v) { if (!vis[tree[id].v]) { vis[tree[id].v] = true; return 1; } return 0; } if (l == r) return 0; int mid = (tree[id].l + tree[id].r) &gt;&gt; 1; return query(ls(id), l, mid) + query(rs(id), mid + 1, r); } int main() { int t = read(); while (t--) { int tot = 0, m = 0, n = read(); memset(vis, false, sizeof(vis)); for (int i = 0; i &lt; n; i++) { int x = read(), y = read(); itv[i].l = x; itv[i].r = y; id[tot++] = x; id[tot++] = y; } sort(id, id + tot); m = tot = unique(id, id + tot) - id; for (int i = 1; i &lt; tot; i++) if (id[i] &gt; id[i - 1] + 1) id[m++] = id[i - 1] + 1; sort(id, id + m); build(1, 1, m); for (int i = 0; i &lt; n; i++) { int x = lower_bound(id, id + m, itv[i].l) - id + 1; int y = lower_bound(id, id + m, itv[i].r) - id + 1; update(1, x, y, i + 1); } printf(&quot;%d\n&quot;, query(1, 1, m)); } return 0; } // Version 2 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; typedef pair&lt;int, int&gt; p; const int maxn = 1e4 + 10; vector&lt;int&gt; id; vector&lt;p&gt; itv; bool vis[maxn &lt;&lt; 2]; struct node { int l, r, v; } tree[maxn &lt;&lt; 4]; inline const int read() { int x = 0, f = 1; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) { if (ch == &#39;-&#39;) f = -1; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - &#39;0&#39;; ch = getchar(); } return x * f; } inline int ls(int id) { return id &lt;&lt; 1; } inline int rs(int id) { return id &lt;&lt; 1 | 1; } void push_up(int id) { tree[id].v = tree[ls(id)].v == tree[rs(id)].v ? tree[ls(id)].v : 0; } void push_down(int id) { if (tree[id].v) tree[ls(id)].v = tree[rs(id)].v = tree[id].v; } void build(int id, int l, int r) { tree[id].v = 0; if ((tree[id].l = l) == (tree[id].r = r)) return; int mid = (l + r) &gt;&gt; 1; build(ls(id), l, mid); build(rs(id), mid + 1, r); // push_up(id); } void update(int id, int l, int r, int v) { if (tree[id].l == l &amp;&amp; tree[id].r == r) { tree[id].v = v; return; } push_down(id); int mid = (tree[id].l + tree[id].r) &gt;&gt; 1; if (r &lt;= mid) update(ls(id), l, r, v); else if (l &gt; mid) update(rs(id), l, r, v); else { update(ls(id), l, mid, v); update(rs(id), mid + 1, r, v); } push_up(id); } int query(int id, int l, int r) { if (tree[id].v) return vis[tree[id].v] ? 0 : (vis[tree[id].v] = true); if (l == r) return 0; // push_down(id); int mid = (tree[id].l + tree[id].r) &gt;&gt; 1; // if (r &lt;= mid) return query(ls(id), l, r); // if (l &gt; mid) return query(rs(id), l, r); return query(ls(id), l, mid) + query(rs(id), mid + 1, r); } int main() { int t = read(); while (t--) { memset(vis, false, sizeof(vis)); id.clear(); itv.clear(); int m = read(); while (m--) { int a = read(), b = read(); itv.push_back(p(a, b)); id.push_back(a); id.push_back(b); } sort(id.begin(), id.end()); id.erase(unique(id.begin(), id.end()), id.end()); int size = (int)id.size(); for (int i = 0; i &lt; size - 1; i++) if (id[i] + 1 &lt; id[i + 1]) id.push_back(id[i] + 1); sort(id.begin(), id.end()); build(1, 1, (int)id.size()); for (int i = 0; i &lt; (int)itv.size(); i++) { int a = (int)(lower_bound(id.begin(), id.end(), itv[i].first) - id.begin()) + 1; int b = (int)(lower_bound(id.begin(), id.end(), itv[i].second) - id.begin()) + 1; update(1, a, b, i + 1); } printf(&quot;%d\n&quot;, query(1, 1, (int)id.size())); } return 0; }]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 UVALive7098 Farey Sums]]></title>
    <url>%2F2019%2F08%2F14%2F%E9%A2%98%E8%A7%A3-UVALive7098-Farey-Sums%2F</url>
    <content type="text"><![CDATA[不难发现，序列的增量与欧拉函数有关。 根据欧拉函数 ${\displaystyle \varphi (n)=\prod _{i=1}^{r}p_{i}^{k_{i}-1}(p_{i}-1)=\prod _{p\mid n}p^{\alpha _{p}-1}(p-1)=n\prod _{p|n}\left(1-{\frac {1}{p}}\right)}$ 可打表再求前缀和。 #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1e4 + 10; int t, n, sum, phi[maxn], presum[maxn]; inline const int read() { int x = 0, f = 1; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) { if (ch == &#39;-&#39;) f = -1; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - &#39;0&#39;; ch = getchar(); } return x * f; } void get_euler() { for (int i = 1; i &lt; maxn; i++) phi[i] = i; for (int i = 2; i &lt; maxn; i++) if (phi[i] == i) for (int j = i; j &lt; maxn; j += i) phi[j] = phi[j] / i * (i - 1); } int main() { get_euler(); for (int i = 1; i &lt; maxn; i++) presum[i] = sum += phi[i]; t = read(); for (int i = 1; i &lt;= t; i++) { n = read(); n = read(); printf(&quot;%d %d/2\n&quot;, i, presum[n] * 3 - 1); } return 0; }]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[欧拉函数 本文转载自 Wikipedia 在数论中，对正整数n，欧拉函数 ${\displaystyle \varphi (n)}$ 是小于或等于n的正整数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为φ函数（由高斯所命名）或是欧拉总计函数（totient function，由西尔维斯特所命名）。 例如 ${\displaystyle \varphi (8)=4}$ ，因为1,3,5,7均和8互质。 欧拉函数实际上是模n的同余类所构成的乘法群（即环 ${\displaystyle \mathbb {Z} /n\mathbb {Z} }$ 的所有单位元组成的乘法群）的阶。这个性质与拉格朗日定理一起构成了欧拉定理的证明。 历史：欧拉函数与费马小定理1736年，欧拉证明了费马小定理： 假若 ${\displaystyle p}$ 为质数， ${\displaystyle a}$ 为任意正整数，那么 ${\displaystyle a^{p}-a}$ 可被 ${\displaystyle p}$ 整除。 然后欧拉予以一般化： 假若 ${\displaystyle a}$ 与 ${\displaystyle n}$ 互质，那么 ${\displaystyle a^{\varphi (n)}-1}$ 可被 ${\displaystyle n}$ 整除。亦即，${\displaystyle a^{\varphi (n)}\equiv 1{\pmod {n}}}$ 。其中 ${\displaystyle \varphi (n)}$ 即为欧拉总计函数。如果 ${\displaystyle n}$ 为质数，那么 ${\displaystyle \varphi (n)=n-1}$ ，因此，有高斯的版本： 假若 ${\displaystyle p}$ 为质数， ${\displaystyle a}$ 与 ${\displaystyle p}$ 互质（ ${\displaystyle a}$ 不是 ${\displaystyle p}$ 的倍数），那么 ${\displaystyle a^{p-1}\equiv 1{\pmod {p}}}$ 。 欧拉函数的值${\displaystyle \varphi (1)=1}$ （小于等于1的正整数中唯一和1互质的数就是1本身）。 若n是质数p的k次幂， ${\displaystyle \varphi (n)=\varphi (p^{k})=p^{k}-p^{k-1}=(p-1)p^{k-1}}$ ，因为除了p的倍数外，其他数都跟n互质。 欧拉函数是积性函数，即是说若m,n互质， ${\displaystyle \varphi (mn)=\varphi (m)\varphi (n)}$ 。证明：设A, B, C是跟m, n, mn互质的数的集，据中国剩余定理， ${\displaystyle A\times B}$ 和 ${\displaystyle C}$ 可建立双射(一一对应)的关系。（或者也可以从初等代数角度给出欧拉函数积性的简单证明）因此 ${\displaystyle \varphi (n)}$ 的值使用算术基本定理便知， 若 ${\displaystyle n=p_{1}^{k_{1}}p_{2}^{k_{2}}\cdots p_{r}^{k_{r}}}$ 则 ${\displaystyle \varphi (n)=\prod _{i=1}^{r}p_{i}^{k_{i}-1}(p_{i}-1)=\prod _{p\mid n}p^{\alpha _{p}-1}(p-1)=n\prod _{p|n}\left(1-{\frac {1}{p}}\right)}$ 。 其中 ${\displaystyle \alpha _{p}}$ 是使得 ${\displaystyle p^{\alpha }}$ 整除 ${\displaystyle n}$ 的最大整数 ${\displaystyle \alpha }$ （这里 ${\displaystyle \alpha _{p_{i}}=k_{i}}$ ）。 例如 ${\displaystyle \varphi (72)=\varphi (2^{3}\times 3^{2})=2^{3-1}(2-1)\times 3^{2-1}(3-1)=2^{2}\times 1\times 3\times 2=24}$ 性质n的欧拉函数 ${\displaystyle \varphi (n)}$ 也是循环群 Cn 的生成元的个数（也是n阶分圆多项式的次数）。Cn 中每个元素都能生成 Cn 的一个子群，即必然是某个子群的生成元。而且按照定义，不同的子群不可能有相同的生成元。此外， Cn 的所有子群都具有 Cd 的形式，其中d整除n（记作d | n）。因此只要考察n的所有因数d，将 Cd 的生成元个数相加，就将得到 Cn 的元素总个数：n。也就是说： ${\displaystyle \sum _{d\mid n}\varphi (d)=n}$ 其中的d为n的正约数。 运用默比乌斯反转公式来“翻转”这个和，就可以得到另一个关于 ${\displaystyle \varphi (n)}$ 的公式： ${\displaystyle \varphi (n)=\sum _{d\mid n}d\cdot \mu (n/d)}$ 其中 μ 是所谓的默比乌斯函数，定义在正整数上。 对任何两个互质的正整数a, m（即 gcd(a,m) = 1）， ${\displaystyle m\geq 2}$ ，有 ${\displaystyle a^{\varphi (m)}\equiv 1{\pmod {m}}}$ 即欧拉定理。 这个定理可以由群论中的拉格朗日定理得出，因为任意与m互质的a都属于环 ${\displaystyle \mathbb {Z} /n\mathbb {Z} }$ 的单位元组成的乘法群 ${\displaystyle \mathbb {Z} /n\mathbb {Z} ^{\times }}$ 当m是质数p时，此式则为： ${\displaystyle a^{p-1}\equiv 1{\pmod {p}}}$ 即费马小定理。 void get_euler() //Version 1 打表 { for (int i = 1; i &lt; maxn; i++) phi[i] = i; for (int i = 2; i &lt; maxn; i++) if (phi[i] == i) for (int j = i; j &lt; maxn; j += i) phi[j] = phi[j] / i * (i - 1); } ll euler(int n) //Version 2 { ll res = 1; for (int i = 2; i &lt;= sqrt(n); i++) { if (n % i == 0) { n /= i; res *= i - 1; while (n % i == 0) { n /= i; res *= i; } } } if (n &gt; 1) res *= n - 1; return res; }]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 Codeforces Round #518 (Div. 1) A. Array Without Local Maximums]]></title>
    <url>%2F2019%2F08%2F12%2F%E9%A2%98%E8%A7%A3-Codeforces-Round-518-Div-1-A-Array-Without-Local-Maximums%2F</url>
    <content type="text"><![CDATA[A. Array Without Local Maximumstime limit per test: 2 secondsmemory limit per test: 512 megabytesinputstandard inputoutputstandard output Ivan unexpectedly saw a present from one of his previous birthdays. It is array of 𝑛 numbers from 1 to 200. Array is old and some numbers are hard to read. Ivan remembers that for all elements at least one of its neighbours ls not less than it, more formally: 𝑎1≤𝑎2, 𝑎𝑛≤𝑎𝑛−1 and 𝑎𝑖≤𝑚𝑎𝑥(𝑎𝑖−1,𝑎𝑖+1) for all 𝑖 from 2 to 𝑛−1. Ivan does not remember the array and asks to find the number of ways to restore it. Restored elements also should be integers from 1 to 200. Since the number of ways can be big, print it modulo 998244353. InputFirst line of input contains one integer 𝑛 (2≤𝑛≤105) — size of the array. Second line of input contains 𝑛 integers 𝑎𝑖 — elements of array. Either 𝑎𝑖=−1 or 1≤𝑎𝑖≤200. 𝑎𝑖=−1 means that 𝑖-th element can’t be read. OutputPrint number of ways to restore the array modulo 998244353. Examplesinput3 1 -1 2output1input2 -1 -1output200NoteIn the first example, only possible value of 𝑎2 is 2. In the second example, 𝑎1=𝑎2 so there are 200 different values because all restored elements should be integers between 1 and 200. Solutiondp[i][j][k]表示当第i个数为j，第i-1个数与第i个数之间的大小关系为k时的方案数目。 (k = 0: a[i - 1] &lt; a[i], k = 1: a[i - 1] = a[i], k = 2: a[i - 1] &gt; a[i]) 状态转移方程 dp[i][j][0] = $\sum_{x=1}^{j-1}$ (dp[i - 1][x][0] + dp[i - 1][x][1] + dp[i - 1][x][2]) dp[i][j][1] = dp[i - 1][j][0] + dp[i - 1][j][1] + dp[i - 1][j][2] dp[i][j][2] = $\sum_{x=j+1}^{200}$ (dp[i - 1][x][1] + dp[i - 1][x][2]) #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 1e5 + 10; const int mod = 998244353; int n, a[maxn]; ll sum, dp[maxn][201][3]; inline const int read() { int x = 0, f = 1; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) { if (ch == &#39;-&#39;) f = -1; ch = getchar(); } while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - &#39;0&#39;; ch = getchar(); } return x * f; } int main() { n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); if (~a[1]) dp[1][a[1]][0] = 1; else for (int j = 1; j &lt;= 200; j++) dp[1][j][0] = 1; for (int i = 2; i &lt;= n; i++) { sum = 0; for (int j = 1; j &lt;= 200; j++) { if (a[i] == -1 || a[i] == j) { dp[i][j][0] = sum; dp[i][j][1] = (dp[i - 1][j][0] + dp[i - 1][j][1] + dp[i - 1][j][2]) % mod; } sum = (sum + dp[i - 1][j][0] + dp[i - 1][j][1] + dp[i - 1][j][2]) % mod; } sum = 0; for (int j = 200; j &gt;= 1; j--) { if (a[i] == -1 || a[i] == j) dp[i][j][2] = sum; sum = (sum + dp[i - 1][j][1] + dp[i - 1][j][2]) % mod; } } sum = 0; for (int j = 1; j &lt;= 200; j++) sum = (sum + dp[n][j][1] + dp[n][j][2]) % mod; printf(&quot;%lld\n&quot;, sum); return 0; }]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 洛谷P2516 [HAOI2010]最长公共子序列]]></title>
    <url>%2F2019%2F08%2F12%2F%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7P2516-HAOI2010-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列X=“x0，x1，…，xm-1”，序列Y=“y0，y1，…，yk-1”是X的子序列，存在X的一个严格递增下标序列&lt;i0，i1，…，ik-1&gt;，使得对所有的j=0，1，…，k-1，有xij = yj。例如，X=“ABCBDAB”，Y=“BCDB”是X的一个子序列。对给定的两个字符序列，求出他们最长的公共子序列长度，以及最长公共子序列个数。 输入格式第1行为第1个字符序列，都是大写字母组成，以”.”结束。长度小于5000。 第2行为第2个字符序列，都是大写字母组成，以”.”结束，长度小于5000。 输出格式第1行输出上述两个最长公共子序列的长度。 第2行输出所有可能出现的最长公共子序列个数，答案可能很大，只要将答案对100,000,000求余即可。 输入输出样例输入 #1 ABCBDAB. BACBBD.输出 #1 4 7题解这是我在洛谷上AC的第二道紫题Orz，听了队友涵哥的讲解我对这题的递推过程颇有感触，特此给出详细解析。 a、b两个字符串的最长公共子序列的长度是唯一的，但最长公共子序列不是唯一的。 用f[i][j]表示a的前i位字符子串和b的前j位字符子串的最长公共子序列（下称lcm(i, j)）的长度，g[i][j]表示lcm(i, j)的种数。 要求最长公共子序列的长度并不难，易知状态转移方程为：f[i][j] = i == j ? f[i][j] = a[i] == b[j] ? f[i - 1][j - 1] + 1 : max(f[i - 1][j], f[i][j - 1])。 要求最长公共子序列的种数，可以给每个状态下的情况分类讨论： ①a[i]和b[j]都属于所有的lcm(i, j)。 ②a[i]属于所有的lcm(i, j)，b[j]并非属于所有的lcm(i, j)。 ③a[i]并非属于所有的lcm(i, j)，b[j]属于所有的lcm(i, j)。 ④a[i]和b[j]都并非属于所有的lcm(i, j)。 若a[i] = b[j]，则f[i][j] = f[i - 1][j - 1] + 1，对应情况①。 若f[i][j] = f[i][j - 1]，则b[j]并非属于所有的lcm(i, j)（可根据逆否命题推断），对应的情况包括②④。 若f[i - 1][j] = f[i][j]，则a[i]并非属于所有的lcm(i, j)（可根据逆否命题推断），对应的情况包括③④。 若f[i][j] = f[i - 1][j - 1]，则对应情况④，并且此时也必满足其上两种的条件。 以上4种条件的结论涵盖各种情况，综上有： if (a[i] == b[j]) g[i][j] += g[i - 1][j - 1] if (f[i][j] == f[i][j - 1]) g[i][j] += g[i][j - 1] if (f[i][j] == f[i - 1][j]) g[i][j] += g[i - 1][j] if (f[i][j] == f[i - 1][j - 1]) g[i][j] -= g[i - 1][j - 1]（容斥原理） 滚动数组优化，k表示i状态，k ^ 1表示i - 1状态。 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 5e3 + 10, mod = 1e8; int n, m, k; char ch, a[maxn], b[maxn]; ll f[2][maxn], g[2][maxn]; int main() { for (int i = 1; (ch = getchar()) != &#39;.&#39;; a[i] = ch, n = i, i++) ; getchar(); for (int i = 1; (ch = getchar()) != &#39;.&#39;; b[i] = ch, m = i, i++) ; for (int i = 0; i &lt;= m; i++) g[0][i] = 1; g[1][0] = 1; for (int i = 1; i &lt;= n; i++, k ^= 1) { for (int j = 1; j &lt;= m; j++) { g[k ^ 1][j] = 0; f[k ^ 1][j] = a[i] == b[j] ? f[k][j - 1] + 1 : max(f[k][j], f[k ^ 1][j - 1]); if (a[i] == b[j]) g[k ^ 1][j] += g[k][j - 1]; if (f[k ^ 1][j] == f[k ^ 1][j - 1]) g[k ^ 1][j] += g[k ^ 1][j - 1]; if (f[k ^ 1][j] == f[k][j]) g[k ^ 1][j] += g[k][j]; if (f[k ^ 1][j] == f[k][j - 1]) g[k ^ 1][j] -= g[k][j - 1]; g[k ^ 1][j] %= mod; } } printf(&quot;%lld\n%lld\n&quot;, f[k][m], g[k][m]); return 0; }]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>最长公共子序列</tag>
        <tag>基础DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[课程设计 学生成绩管理系统]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[功能导图 数据文件 password.txt student.txt subject.txt 源文件main.cpp #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;windows.h&gt; #include &quot;data.h&quot; #include &quot;student.h&quot; #include &quot;subject.h&quot; #include &quot;system.h&quot; int main() { welcome(); login(); load(); do showMenu(); while (chooseFunc()); save(); system(&quot;pause&quot;); return 0; } 头文件data.h #pragma once using namespace std; struct Sub { string name; double weight; }; map&lt;int, Sub&gt; sub; //存储所有科目信息 struct Stu { string name, id; int claz; map&lt;int, int&gt; m; double gpa() { double suma = 0, sumb = 0; for (auto it = m.begin(); it != m.end(); it++) { suma += it-&gt;second * sub[it-&gt;first].weight; sumb += sub[it-&gt;first].weight; } return suma / sumb; } int sum() { int res = 0; for (auto it = m.begin(); it != m.end(); it++) res += it-&gt;second; return res; } }; vector&lt;Stu&gt; stu; //存储所有学生信息 vector&lt;Stu&gt; temp; //存储某次查询得到的学生信息 student.h #pragma once using namespace std; void stuInsert() { string name, id; char c; int claz, score; map&lt;int, int&gt; m; cout &lt;&lt; &quot;请输入学生信息，按回车键开始&quot; &lt;&lt; endl; getchar(); while ((c = getchar()) != &#39;0&#39;) { system(&quot;cls&quot;); m.clear(); cout &lt;&lt; &quot;姓名：&quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;学号：&quot;; cin &gt;&gt; id; cout &lt;&lt; &quot;班级：&quot;; cin &gt;&gt; claz; for (auto it = sub.begin(); it != sub.end(); it++) { cout &lt;&lt; it-&gt;second.name &lt;&lt; &quot;成绩：&quot;; cin &gt;&gt; score; m[it-&gt;first] = score; } stu.push_back(Stu{ name, id, claz, m }); cout &lt;&lt; endl &lt;&lt; &quot;按回车键继续输入，输入0返回根目录&quot; &lt;&lt; endl; getchar(); } } void stuDelete() { menu: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入您需要进行的操作标号&quot; &lt;&lt; endl; cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; &quot;0\t返回根目录&quot; &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; &quot;1\t按指定学生编号逐个删除&quot; &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; &quot;2\t按指定班级编号批量删除&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; string id; int claz, ope; cin &gt;&gt; ope; switch (ope) { case 0: break; case 1: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入需要删除信息的学生编号：&quot;; while (cin &gt;&gt; id &amp;&amp; id != &quot;0&quot;) { bool flag = false; //标记是否查询到对象 for (int i = 0; i &lt; (int)stu.size(); i++) //遍历vector，逐个检验学生是否与指定编号匹配 { if (stu[i].id == id) { system(&quot;cls&quot;); flag = true; //查询到对象 cout &lt;&lt; &quot;请确认是否删除该学生的信息[Y/N]&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;姓名&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;学号&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;班级&quot;; for (auto it = sub.begin(); it != sub.end(); it++) cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;second.name; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;总成绩&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;平均学分绩点&quot;; cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].name &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].id &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].claz; for (auto it = sub.begin(); it != sub.end(); it++) { if (stu[i].m.count(it-&gt;first)) cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].m[it-&gt;first]; else cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;尚未录入&quot;; } cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].sum() &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].gpa(); cout &lt;&lt; endl; string ope; cin &gt;&gt; ope; if (ope == &quot;Y&quot; || ope == &quot;y&quot;) { stu.erase(stu.begin() + i); cout &lt;&lt; endl &lt;&lt; &quot;成功删除&quot; &lt;&lt; endl; } else cout &lt;&lt; endl &lt;&lt; &quot;取消删除&quot; &lt;&lt; endl; break; } } if (!flag) //未查询到对象 cout &lt;&lt; endl &lt;&lt; &quot;不存在该学生编号！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); cout &lt;&lt; &quot;（输入0返回上级目录）&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;请继续输入需要删除信息的学生编号：&quot;; } goto menu; case 2: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入需要删除信息的班级编号：&quot;; while (cin &gt;&gt; claz &amp;&amp; claz) { bool flag = false; //标记是否查询到对象 for (auto it = stu.begin(); it != stu.end();) //遍历vector，逐个检验学生是否属于指定班级 { if (it-&gt;claz == claz) { system(&quot;pause&quot;); system(&quot;cls&quot;); flag = true; //查询到对象 cout &lt;&lt; &quot;请确认是否删除该学生的信息[Y/N]&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;姓名&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;学号&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;班级&quot;; for (auto iter = sub.begin(); iter != sub.end(); iter++) cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; iter-&gt;second.name; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;总成绩&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;平均学分绩点&quot;; cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;name &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;id &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;claz; for (auto iter = sub.begin(); iter != sub.end(); iter++) { if (it-&gt;m.count(iter-&gt;first)) cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;m[iter-&gt;first]; else cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;尚未录入&quot;; } cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;sum() &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;gpa(); cout &lt;&lt; endl; string ope; cin &gt;&gt; ope; if (ope == &quot;Y&quot; || ope == &quot;y&quot;) { it = stu.erase(it); //迭代器stu.erase(it)指向被删除元素的下一个，利用其返回值避免当前迭代器失效 cout &lt;&lt; endl &lt;&lt; &quot;成功删除&quot; &lt;&lt; endl; } else { cout &lt;&lt; endl &lt;&lt; &quot;取消删除&quot; &lt;&lt; endl; it++; } } else it++; } if (!flag) //未查询到对象 cout &lt;&lt; endl &lt;&lt; &quot;不存在该班级编号！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); cout &lt;&lt; &quot;（输入0返回上级目录）&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;请继续输入需要删除信息的班级编号：&quot;; } goto menu; default: cout &lt;&lt; &quot;指令无效，请重新输入！&quot; &lt;&lt; endl; system(&quot;pause&quot;); goto menu; } } int suborder; //存储某次按指定科目排序的科目次序 //以下为各种条件下的排序规则函数 bool cmp_nameAsc(const Stu &amp;a, const Stu &amp;b) { return a.name != b.name ? a.name &lt; b.name : a.id &lt; b.id; } bool cmp_nameDes(const Stu &amp;a, const Stu &amp;b) { return a.name != b.name ? a.name &gt; b.name : a.id &lt; b.id; } bool cmp_idAsc(const Stu &amp;a, const Stu &amp;b) { return a.id &lt; b.id; } bool cmp_idDes(const Stu &amp;a, const Stu &amp;b) { return a.id &gt; b.id; } bool cmp_sumAsc(Stu &amp;a, Stu &amp;b) { return a.sum() != b.sum() ? a.sum() &lt; b.sum() : a.id &lt; b.id; } bool cmp_sumDes(Stu &amp;a, Stu &amp;b) { return a.sum() != b.sum() ? a.sum() &gt; b.sum() : a.id &lt; b.id; } bool cmp_gpaAsc(Stu &amp;a, Stu &amp;b) { return a.gpa() != b.gpa() ? a.gpa() &lt; b.gpa() : a.gpa() &lt; b.gpa(); } bool cmp_gpaDes(Stu &amp;a, Stu &amp;b) { return a.gpa() != b.gpa() ? a.gpa() &gt; b.gpa() : a.gpa() &lt; b.gpa(); } bool cmp_subAsc(Stu &amp;a, Stu &amp;b) { int i = 0, sid; for (auto it = sub.begin(); it != sub.end() &amp;&amp; i &lt; suborder; it++, i++) sid = it-&gt;first; if (a.m.count(sid) &amp;&amp; b.m.count(sid)) return a.m[sid] != b.m[sid] ? a.m[sid] &lt; b.m[sid] : a.id &lt; b.id; return a.m.count(sid) ? false : b.m.count(sid) ? true : a.id &lt; b.id; } bool cmp_subDes(Stu &amp;a, Stu &amp;b) { int i = 0, sid; for (auto it = sub.begin(); it != sub.end() &amp;&amp; i &lt; suborder; it++, i++) sid = it-&gt;first; if (a.m.count(sid) &amp;&amp; b.m.count(sid)) return a.m[sid] != b.m[sid] ? a.m[sid] &gt; b.m[sid] : a.id &lt; b.id; return a.m.count(sid) ? true : b.m.count(sid) ? false : a.id &lt; b.id; } void print() //打印某次查询得到的学生信息 { cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;姓名&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;学号&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;班级&quot;; for (auto it = sub.begin(); it != sub.end(); it++) cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;second.name; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;总成绩&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;平均学分绩点&quot;; cout &lt;&lt; endl &lt;&lt; endl; for (int i = 0; i &lt; (int)temp.size(); i++) { cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; temp[i].name &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; temp[i].id &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; temp[i].claz; for (auto it = sub.begin(); it != sub.end(); it++) { if (temp[i].m.count(it-&gt;first)) cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; temp[i].m[it-&gt;first]; else cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;尚未录入&quot;; } cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; temp[i].sum() &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; temp[i].gpa() &lt;&lt; endl &lt;&lt; endl; } } void stuFind() { menu1: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入您需要进行的操作标号&quot; &lt;&lt; endl; cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; &quot;0\t返回根目录&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;1\t按指定学生姓名查询&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;2\t按指定学生编号查询&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;3\t按指定班级编号查询&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; string name, id; int claz, ope; cin &gt;&gt; ope; switch (ope) { case 0: break; case 1: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入学生姓名：&quot;; while (cin &gt;&gt; name &amp;&amp; name != &quot;0&quot;) { temp.clear(); bool flag = false; //标记是否查询到对象 for (int i = 0; i &lt; (int)stu.size(); i++) { if (stu[i].name == name) { flag = true; //查询到对象 temp.push_back(stu[i]); } } if (!flag) //未查询到对象 cout &lt;&lt; endl &lt;&lt; &quot;不存在该学生姓名！&quot; &lt;&lt; endl; else { system(&quot;cls&quot;); print(); } system(&quot;pause&quot;); system(&quot;cls&quot;); cout &lt;&lt; &quot;（输入0返回上级目录）&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;请继续输入需要查询的学生姓名：&quot;; } goto menu1; case 2: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入学生编号：&quot;; while (cin &gt;&gt; id &amp;&amp; id != &quot;0&quot;) { bool flag = false; //标记是否查询到对象 for (int i = 0; i &lt; (int)stu.size(); i++) { if (stu[i].id == id) { system(&quot;cls&quot;); flag = true; //查询到对象 cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;姓名&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;学号&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;班级&quot;; for (auto it = sub.begin(); it != sub.end(); it++) cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;second.name; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;总成绩&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;平均学分绩点&quot;; cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].name &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].id &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].claz; for (auto it = sub.begin(); it != sub.end(); it++) { if (stu[i].m.count(it-&gt;first)) cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].m[it-&gt;first]; else cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;尚未录入&quot;; } cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].sum() &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].gpa(); cout &lt;&lt; endl; } } if (!flag) //未查询到对象 cout &lt;&lt; endl &lt;&lt; &quot;不存在该学生编号！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); cout &lt;&lt; &quot;（输入0返回上级目录）&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;请继续输入需要查询的学生编号：&quot;; } goto menu1; case 3: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入班级编号：&quot;; while (cin &gt;&gt; claz &amp;&amp; claz) { temp.clear(); bool flag = false; //标记是否查询到对象 for (int i = 0; i &lt; (int)stu.size(); i++) { if (stu[i].claz == claz) { flag = true; //查询到对象 temp.push_back(stu[i]); } } if (!flag) //未查询到对象 { cout &lt;&lt; endl &lt;&lt; &quot;不存在该班级编号！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); cout &lt;&lt; &quot;（输入0返回上级目录）&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;请继续输入需要查询的班级编号：&quot;; continue; } menu2: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入您需要进行的操作标号&quot; &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; setw(5) &lt;&lt; 0 &lt;&lt; &quot; 重新输入班级编号&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; setw(5) &lt;&lt; 1 &lt;&lt; &quot; 按学生姓名字典升序&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; setw(5) &lt;&lt; 2 &lt;&lt; &quot; 按学生姓名字典降序&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; setw(5) &lt;&lt; 3 &lt;&lt; &quot; 按学生编号升序&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; setw(5) &lt;&lt; 4 &lt;&lt; &quot; 按学生编号降序&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; setw(5) &lt;&lt; 5 &lt;&lt; &quot; 按总成绩升序&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; setw(5) &lt;&lt; 6 &lt;&lt; &quot; 按总成绩降序&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; setw(5) &lt;&lt; 7 &lt;&lt; &quot; 按平均学分绩点升序&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; setw(5) &lt;&lt; 8 &lt;&lt; &quot; 按平均学分绩点降序&quot; &lt;&lt; endl &lt;&lt; endl; int order = 9; for (auto it = sub.begin(); it != sub.end(); it++, order += 2) { cout &lt;&lt; setw(5) &lt;&lt; order &lt;&lt; &quot; 按&quot; &lt;&lt; it-&gt;second.name &lt;&lt; &quot;成绩升序&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; setw(5) &lt;&lt; order + 1 &lt;&lt; &quot; 按&quot; &lt;&lt; it-&gt;second.name &lt;&lt; &quot;成绩降序&quot; &lt;&lt; endl &lt;&lt; endl; } cout &lt;&lt; &quot;--------------------------------------------------&quot; &lt;&lt; endl; int ope; cin &gt;&gt; ope; switch (ope) { case 0: break; case 1: sort(temp.begin(), temp.end(), cmp_nameAsc); system(&quot;cls&quot;); print(); system(&quot;pause&quot;); goto menu2; case 2: sort(temp.begin(), temp.end(), cmp_nameDes); system(&quot;cls&quot;); print(); system(&quot;pause&quot;); goto menu2; case 3: sort(temp.begin(), temp.end(), cmp_idAsc); system(&quot;cls&quot;); print(); system(&quot;pause&quot;); goto menu2; case 4: sort(temp.begin(), temp.end(), cmp_idDes); system(&quot;cls&quot;); print(); system(&quot;pause&quot;); goto menu2; case 5: sort(temp.begin(), temp.end(), cmp_sumAsc); system(&quot;cls&quot;); print(); system(&quot;pause&quot;); goto menu2; case 6: sort(temp.begin(), temp.end(), cmp_sumDes); system(&quot;cls&quot;); print(); system(&quot;pause&quot;); goto menu2; case 7: sort(temp.begin(), temp.end(), cmp_gpaAsc); system(&quot;cls&quot;); print(); system(&quot;pause&quot;); goto menu2; case 8: sort(temp.begin(), temp.end(), cmp_gpaDes); system(&quot;cls&quot;); print(); system(&quot;pause&quot;); goto menu2; default: if (ope &gt;= 9 &amp;&amp; ope &lt;= (int)sub.size() * 2 + 7) { if (ope &amp; 1) { suborder = (ope - 9) / 2 + 1; sort(temp.begin(), temp.end(), cmp_subAsc); } else { suborder = (ope - 10) / 2 + 1; sort(temp.begin(), temp.end(), cmp_subDes); } system(&quot;cls&quot;); print(); } else cout &lt;&lt; &quot;指令无效，请重新输入&quot; &lt;&lt; endl; system(&quot;pause&quot;); goto menu2; } system(&quot;cls&quot;); cout &lt;&lt; &quot;（输入0返回上级目录）&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;请继续输入需要查询的班级编号：&quot;; } goto menu1; default: cout &lt;&lt; &quot;指令无效，请重新输入&quot; &lt;&lt; endl; system(&quot;pause&quot;); goto menu1; } } void stuModify() { menu: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入您需要进行的操作标号&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; &quot;0\t返回根目录&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;1\t修改指定学生编号&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;2\t修改指定班级编号&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl; string id; int ope, score; cin &gt;&gt; ope; switch (ope) { case 0: break; case 1: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入需要修改的学生编号：&quot;; while (cin &gt;&gt; id &amp;&amp; id != &quot;0&quot;) { bool flag = false; //标记是否查询到对象 for (int i = 0; i &lt; (int)stu.size(); i++) { if (stu[i].id == id) { system(&quot;cls&quot;); flag = true; //查询到对象 cout &lt;&lt; &quot;该学生的当前信息如下：&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;姓名&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;学号&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;班级&quot;; for (auto it = sub.begin(); it != sub.end(); it++) cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;second.name; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;总成绩&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;平均学分绩点&quot;; cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].name &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].id &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].claz; for (auto it = sub.begin(); it != sub.end(); it++) { if (stu[i].m.count(it-&gt;first)) cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].m[it-&gt;first]; else cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;尚未录入&quot;; } cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].sum() &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; stu[i].gpa(); cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; &quot;请输入修改后的学生信息：&quot; &lt;&lt; endl &lt;&lt; endl; string name; int claz; cout &lt;&lt; &quot;姓名：&quot;; cin &gt;&gt; name; stu[i].name = name; cout &lt;&lt; &quot;学号：&quot;; cin &gt;&gt; id; stu[i].id = id; cout &lt;&lt; &quot;班级：&quot;; cin &gt;&gt; claz; stu[i].claz = claz; for (auto it = sub.begin(); it != sub.end(); it++) { cout &lt;&lt; it-&gt;second.name &lt;&lt; &quot;成绩：&quot;; cin &gt;&gt; score; stu[i].m[it-&gt;first] = score; } cout &lt;&lt; endl &lt;&lt; &quot;成功修改&quot; &lt;&lt; endl; break; } } if (!flag) //未查询到对象 cout &lt;&lt; endl &lt;&lt; &quot;不存在该学生编号！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); cout &lt;&lt; &quot;（输入0返回上级目录）&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;请继续输入需要修改的学生编号：&quot;; } goto menu; case 2: int claz, newnum; system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入需要修改的班级编号：&quot;; while (cin &gt;&gt; claz &amp;&amp; claz) { bool flag = false; //标记是否查询到对象 for (int i = 0; i &lt; (int)stu.size(); i++) { if (stu[i].claz == claz) { flag = true; //查询到对象 cout &lt;&lt; &quot;请输入修改后的班级编号：&quot;; cin &gt;&gt; newnum; stu[i].claz = newnum; cout &lt;&lt; endl &lt;&lt; &quot;成功修改&quot; &lt;&lt; endl; } } if (!flag) //未查询到对象 cout &lt;&lt; endl &lt;&lt; &quot;不存在该班级编号！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); cout &lt;&lt; &quot;（输入0返回上级目录）&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;请继续输入需要修改的班级编号：&quot;; } goto menu; default: cout &lt;&lt; &quot;指令无效，请重新输入&quot; &lt;&lt; endl; system(&quot;pause&quot;); goto menu; } } subject.h #pragma once void subInsert() { string name; int sid; double weight; system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入新科目名称：&quot;; cin &gt;&gt; name; bool flag = false; //标记是否输入未重复编号 while (!flag) { flag = true; cout &lt;&lt; &quot;请输入新科目编号：&quot;; cin &gt;&gt; sid; for (auto it = sub.begin(); it != sub.end(); it++) { if (it-&gt;first == sid) { flag = false; cout &lt;&lt; &quot;该编号已存在！&quot; &lt;&lt; endl &lt;&lt; endl; break; } } } cout &lt;&lt; &quot;请输入新科目学分：&quot;; cin &gt;&gt; weight; sub[sid].name = name; sub[sid].weight = weight; cout &lt;&lt; endl &lt;&lt; &quot;成功增添&quot; &lt;&lt; endl; system(&quot;pause&quot;); } void subDelete() { menu: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入您需要进行的操作标号&quot; &lt;&lt; endl; cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; &quot;0\t返回根目录&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;1\t按指定编号删除学科&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;2\t按指定名称删除学科&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; string name; int ope, sid; cin &gt;&gt; ope; bool flag = false; switch (ope) { case 0: break; case 1: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入需要删除信息的学科编号：&quot;; cin &gt;&gt; sid; flag = false; //标记是否查询到对象 for (auto it = sub.begin(); it != sub.end(); it++) //遍历map，逐个检验学科是否与指定编号匹配 { if (it-&gt;first == sid) { flag = true; //查询到对象 sub.erase(it); for (int i = 0; i &lt; (int)stu.size(); i++) { if (stu[i].m.count(sid)) stu[i].m.erase(sid); } cout &lt;&lt; endl &lt;&lt; &quot;成功删除&quot; &lt;&lt; endl; break; } } if (!flag) //未查询到对象 cout &lt;&lt; endl &lt;&lt; &quot;不存在该学科编号！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); goto menu; case 2: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入需要删除信息的学科名称：&quot;; cin &gt;&gt; name; flag = false; //标记是否查询到对象 for (auto it = sub.begin(); it != sub.end(); it++) //遍历map，逐个检验学科是否与指定名称匹配 { if (it-&gt;second.name == name) { flag = true; //查询到对象 for (int i = 0; i &lt; (int)stu.size(); i++) { if (stu[i].m.count(it-&gt;first)) stu[i].m.erase(it-&gt;first); } sub.erase(it); cout &lt;&lt; endl &lt;&lt; &quot;成功删除&quot; &lt;&lt; endl; break; } } if (!flag) //未查询到对象 cout &lt;&lt; endl &lt;&lt; &quot;不存在该学科名称！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); goto menu; default: cout &lt;&lt; &quot;指令无效，请重新输入！&quot; &lt;&lt; endl; system(&quot;pause&quot;); goto menu; } } void subModify() { menu: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入您需要进行的操作标号&quot; &lt;&lt; endl; cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; &quot;0\t返回根目录&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;1\t按指定编号修改学科&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;2\t按指定名称修改学科&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; string name; int ope, sid; cin &gt;&gt; ope; double weight; bool flag = false; switch (ope) { case 0: break; case 1: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入需要修改信息的学科编号：&quot;; cin &gt;&gt; sid; flag = false; //标记是否查询到对象 for (auto it = sub.begin(); it != sub.end(); it++) //遍历map，逐个检验学科是否与指定编号匹配 { if (it-&gt;first == sid) { flag = true; //查询到对象 bool flagg = false; //标记是否输入未重复编号 while (!flagg) { flagg = true; cout &lt;&lt; &quot;请输入修改后的科目编号：&quot;; cin &gt;&gt; sid; for (auto it = sub.begin(); it != sub.end(); it++) { if (it-&gt;first == sid) { flagg = false; cout &lt;&lt; &quot;该编号已存在！&quot; &lt;&lt; endl &lt;&lt; endl; break; } } } for (int i = 0; i &lt; (int)stu.size(); i++) { if (stu[i].m.count(it-&gt;first)) { stu[i].m[sid] = stu[i].m[it-&gt;first]; stu[i].m.erase(it-&gt;first); } } cout &lt;&lt; &quot;请输入修改后的科目名称：&quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;请输入修改后的科目学分：&quot;; cin &gt;&gt; weight; sub[sid] = Sub{ name, weight }; sub.erase(it); cout &lt;&lt; endl &lt;&lt; &quot;成功修改&quot; &lt;&lt; endl; break; } } if (!flag) //未查询到对象 cout &lt;&lt; endl &lt;&lt; &quot;不存在该学科编号！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); goto menu; case 2: system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入需要修改信息的学科名称：&quot;; cin &gt;&gt; name; flag = false; //标记是否查询到对象 for (auto it = sub.begin(); it != sub.end(); it++) //遍历map，逐个检验学科是否与指定名称匹配 { if (it-&gt;second.name == name) { flag = true; //查询到对象 bool flagg = false; //标记是否输入未重复编号 while (!flagg) { flagg = true; cout &lt;&lt; &quot;请输入修改后的科目编号：&quot;; cin &gt;&gt; sid; for (auto it = sub.begin(); it != sub.end(); it++) { if (it-&gt;first == sid) { flagg = false; cout &lt;&lt; &quot;该编号已存在！&quot; &lt;&lt; endl &lt;&lt; endl; break; } } } for (int i = 0; i &lt; (int)stu.size(); i++) { if (stu[i].m.count(it-&gt;first)) { stu[i].m[sid] = stu[i].m[it-&gt;first]; stu[i].m.erase(it-&gt;first); } } cout &lt;&lt; &quot;请输入修改后的科目名称：&quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;请输入修改后的科目学分：&quot;; cin &gt;&gt; weight; sub[sid] = Sub{ name, weight }; sub.erase(it); cout &lt;&lt; endl &lt;&lt; &quot;成功修改&quot; &lt;&lt; endl; break; } } if (!flag) //未查询到对象 cout &lt;&lt; endl &lt;&lt; &quot;不存在该学科名称！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); goto menu; default: cout &lt;&lt; &quot;指令无效，请重新输入！&quot; &lt;&lt; endl; system(&quot;pause&quot;); goto menu; } } void subDisplay() //显示各项学科信息 { system(&quot;cls&quot;); cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;科目编号&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;科目名称&quot; &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; &quot;科目学分&quot; &lt;&lt; endl &lt;&lt; endl; for (auto it = sub.begin(); it != sub.end(); it++) cout &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;first &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;second.name &lt;&lt; std::right &lt;&lt; setw(15) &lt;&lt; it-&gt;second.weight &lt;&lt; endl &lt;&lt; endl; system(&quot;pause&quot;); } system.h #pragma once using namespace std; void welcome() { system(&quot;color 3f&quot;); cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;欢迎使用学生信息管理系统！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;正在加载，请稍后&quot; &lt;&lt; endl &lt;&lt; endl; for (int i = 0; i &lt; 20; i++) { Sleep(100); cout &lt;&lt; &quot;■&quot;; } cout &lt;&lt; endl; } void login() //实现登录功能 { system(&quot;pause&quot;); system(&quot;cls&quot;); ifstream file; file.open(&quot;./src/password.txt&quot;); if (!file) { cout &lt;&lt; &quot;数据异常，无法访问！&quot; &lt;&lt; endl; system(&quot;pause&quot;); exit(0); } string pass, input; file &gt;&gt; pass; file.close(); cout &lt;&lt; &quot;请输入密码：&quot;; while (cin &gt;&gt; input &amp;&amp; pass != input) //检验输入串与密码是否匹配 { if (input == &quot;0&quot;) //输入指令0，取消登录操作 { system(&quot;pause&quot;); exit(0); } system(&quot;cls&quot;); cout &lt;&lt; &quot;（输入0退出系统）&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;密码错误，请重试：&quot;; } cout &lt;&lt; endl &lt;&lt; &quot;登录成功！&quot; &lt;&lt; endl; system(&quot;pause&quot;); } void load() //从文件中读取全部学生信息和科目信息 { ifstream file; file.open(&quot;./src/subject.txt&quot;); if (!file) { cout &lt;&lt; &quot;数据异常，无法访问！&quot; &lt;&lt; endl; system(&quot;pause&quot;); exit(0); } int sid; while (file &gt;&gt; sid) file &gt;&gt; sub[sid].name &gt;&gt; sub[sid].weight; file.close(); file.open(&quot;./src/student.txt&quot;); if (!file) { cout &lt;&lt; &quot;数据异常，无法访问！&quot; &lt;&lt; endl; system(&quot;pause&quot;); exit(0); } string name, id; int claz, score, nsub; map&lt;int, int&gt; m; while (file &gt;&gt; name &gt;&gt; id &gt;&gt; claz &gt;&gt; nsub) { m.clear(); for (int i = 0; i &lt; nsub; i++) { file &gt;&gt; sid &gt;&gt; score; m[sid] = score; } stu.push_back(Stu{ name, id, claz, m }); } } void save() //程序运行结束前，将学生信息和科目信息写入文件 { ofstream student(&quot;./src/student.txt&quot;); for (int i = 0; i &lt; (int)stu.size(); i++) { student &lt;&lt; stu[i].name &lt;&lt; &quot; &quot; &lt;&lt; stu[i].id &lt;&lt; &quot; &quot; &lt;&lt; stu[i].claz &lt;&lt; &quot; &quot; &lt;&lt; (int)stu[i].m.size(); for (auto it = stu[i].m.begin(); it != stu[i].m.end(); it++) student &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second; student &lt;&lt; endl; } student.close(); ofstream subject(&quot;./src/subject.txt&quot;); for (auto it = sub.begin(); it != sub.end(); it++) subject &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second.name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second.weight &lt;&lt; endl; } void showMenu() { system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入您需要进行的操作标号&quot; &lt;&lt; endl; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; &quot;0\t退出系统&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;1\t修改密码&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;2\t增添学生信息&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;3\t删除学生信息&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;4\t修改学生信息&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;5\t查询学生信息&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;6\t增添科目信息&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;7\t删除科目信息&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;8\t修改科目信息&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;9\t显示科目信息&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; } void changePass() { system(&quot;cls&quot;); cout &lt;&lt; &quot;请输入3-10位新密码：&quot; &lt;&lt; endl; string pass; while (cin &gt;&gt; pass &amp;&amp; (pass.length() &lt; 3 || pass.length() &gt; 10)) //检验新密码长度是否符合要求 { system(&quot;cls&quot;); cout &lt;&lt; &quot;密码不符合要求，请重新输入：&quot; &lt;&lt; endl; } ofstream file(&quot;./src/password.txt&quot;); file &lt;&lt; pass; file.close(); system(&quot;cls&quot;); cout &lt;&lt; &quot;密码修改成功，新密码为：&quot; &lt;&lt; pass &lt;&lt; endl; system(&quot;pause&quot;); } bool chooseFunc() { int ope; cin &gt;&gt; ope; switch (ope) { case 0: return false; case 1: changePass(); break; case 2: stuInsert(); break; case 3: stuDelete(); break; case 4: stuModify(); break; case 5: stuFind(); break; case 6: subInsert(); break; case 7: subDelete(); break; case 8: subModify(); break; case 9: subDisplay(); break; default: cout &lt;&lt; &quot;指令无效，请重新输入！&quot; &lt;&lt; endl; system(&quot;pause&quot;); } return true; }]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-2019 大学一年级总结]]></title>
    <url>%2F2019%2F06%2F13%2F2018-2019-%E5%A4%A7%E5%AD%A6%E4%B8%80%E5%B9%B4%E7%BA%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[比成功更重要的是要有内在的丰富和自己喜欢做的事情 时间飞逝，大一生活即将结束，我们也要成为人家的学长了。 这一年来的收获不少：丰富了一点社会经验，从一个幼稚的未成年人逐渐向成年人过渡；能做自己喜欢做的事情，从一个编程小白变成了ACMer；还结识了身边许多闪闪发光的dalao。 缺憾也挺多：没有花时间学习学校安排的课程；作息安排紊乱，常熬夜，没有花时间锻炼身体；阅读贫乏，没有接触人文社科。 学校课程方面对学校教务处课程安排表示不理解。作为计算机专业学生，为什么还得学大物（大雾）？为什么还得做物理实验？大学生增负虚空加课，全周全天满课了解一下？其实物理实验课不无好处：去高海拔的物院上课、交作业是一个锻炼身体的过程 #滑稽。 再就是形式主义的事情太多了：青年大学习、企业家论坛报告……虽然一直以来我都是抱着水一水的态度，但还是烦心。 说实话这一年来没怎么用心听课，虽说没有像某些人说的那样“必修课选逃，选修课必逃”，但身在曹营心在汉，感觉也差不多了：课上刷刷微博、逛逛知乎、看看CSDN，偶尔再敲敲代码……作业也必是不会写 #惭愧，貌似只有定期的英语作文会认真完成。 两个学期绩点平平，要不是考前临时突击铁定挂科==。看了一遍成绩单发现班上dalao众多，心想要想和他们通过学科绩点竞争保研名额难如登天。 很佩服那些擅长时间安排的同学，他们总是保持良好的作息习惯，早睡早起雷打不动，每天三点一线：宿舍–教室（图书馆/实验室）–食堂，并且总是能够利用碎片化时间学习，不受各种外界因素干扰。 我的室友、ACM队友涵哥就是一个典范。他曾给我分享过一个故事，出自《人性的弱点》。 Image1 Image2 别把工作当成负担，无论它是否是你所热爱的。 对我来说虽然拼绩点已经没有意义，但尽量学好各学科还是很有必要的。高数、线代、离散、数电……这些数理课程都很重要，是将来各大CS专业课程的基础。在此立下flag：下学期好好学习。 科研竞赛方面在上大学之前没有编程语言基础，对OI、ICPC等等更是一无所闻。在袁老师的引导下，第一学期循序渐进地学习了C语言程序设计，开始接触ACM。初学C语言那段时间是痛并快乐着的：老师每次在PTA上布置的题集得花一两天时间并且熬夜才能做完，肝完几套题下来编程水平也上去了，还是挺有成就感的。 ACM竞赛主要考察选手的数据结构和算法能力，但是要通过代码实现它们首先得有扎实的程序设计基础。在学习了一个学期的C语言之后，我和几个同学约定，利用寒假时间刷完了PAT乙级的往年题集。一共95道题，每天3-5道，不到一个月就能完结。PAT乙级过关，差不多便掌握了最基本的数据存储结构和相关算法，初步具备了问题抽象和建模的能力。所以如今我总是安利身边编程基础稍薄弱的同学：快去刷PAT！在寒假刷题的过程中发现了柳神的博客，通过学习她总结的《从C语言转C++简明教程》上手了STL，鸟枪换大炮。柳神的题解十分简明，并且算法高效。有时候做题没有思路或者AC了但觉得自己的代码冗长，思路不够清晰，都应该向她学习一下。 安利一波柳神的博客：https://blog.csdn.net/liuchuohttps://www.liuchuo.net/ 这学期开学后先后参加了PAT、CCCC-GPLT、ACM校内新星赛、蓝桥杯省赛。之后又和两位dalao组了队，参加了校赛、市赛、省赛。讲真，搞ACM竞赛是一件高投入但低回报的事情。提高水平的一个必要条件是花大量的时间刷大量的题，有时候要想学会一个新算法、解决一道题得花上一整天。在我看来编程是一门可以锻炼人的逻辑思维能力的艺术，我已经做好吊死在ACM这棵树上的打算了（这话听起来是不是很耳熟233）。 目前学到的一些基础数据结构与算法，只能应付一些水题。接下来的计划是暑假留校集训，这对我们新队员来说肯定会是一次很大的提升。 这里有一份别人收集整理的kuangbin题单，希望有朝一日能够刷完。https://vjudge.net/article/752 第二学期加入了一个高富帅学长带队的关于AI音乐的国创科研项目。当初申请加入项目的时候，我说我有相对音感，学长连面试都没有就录用我了（可想而知学长多么缺人）。加入项目之后主要是做些搬砖的活：收集乐谱、帮助完成数据集之类的，没有多少技术含量，下学期学完Java之后也许能在软件开发方面帮点忙。跟着去小学里做过推广，发传单、给小朋友做乐理普及之类的。还有一次路边地推的经历（其实更像是街头卖艺）。后来学长又把我拉进了他的公司，任命我为项目经理233，还给了我股份，看来以后要多为学长卖命了555（误）。 其他方面貌似没有什么特别的经历。清明小长假和室友一起去青岛玩了两天，五一小长假又把威海几个重要的景点逛了逛，挺快乐的。 一年来没看几本书，阅读贫乏所以语言贫乏。《未来简史》挺nice，但还没看完。在心情低落的那段时间，好友推荐我看了卢思浩的《愿有人陪你颠沛流离》。 比成功更重要的是要有内在的丰富和自己喜欢做的事情。 《啊哈！算法》、《算法竞赛入门经典》入门ACM不错（在我们宿舍紫书人手一本）。前些天又从祥神那里嫖来了《挑战程序设计竞赛》，要花时间啃。原版《C程序设计语言》买来至今还没翻过，陪着《Python3网络爬虫开发实战》在书架上吃灰。 一年来电影电视剧看了不少，以科幻、惊悚、悬疑和喜剧为主。看过的电影大都是爆米花式，没有几部是值得回味的。对漫威电影宇宙还不大明了，以后找时间补。在手里VPS还能用时，看了Netflix出品的一些好剧：反乌托邦《黑镜》、交互式电影《黑镜：潘达斯奈基》、成人向《性爱自修室》、科幻惊悚《怪奇物语》、血腥暴力动画《爱、死亡和机器人》，还有BBC的《9号秘事》、《神探夏洛克》。听说明年出神夏第五季，期待。暑假前追《长安十二时辰》，难得的国产好剧。 生活不能没有音乐，但歌单类型从以前的摇滚、电音变成了民谣、古典。华语流行音乐早听腻了，也许因为4536251烂大街？最近循环次数最多的几首纯音乐：Flower Dance、Heart in a Bottle、Cut in love（隐形守护者插曲）、Andhadhun Theme 02（调音师插曲）。上大学之后就再没玩过乐器，以前那些半会不会的怕是都忘光了。想弄块MIDI键盘耍耍但太贵了舍不得买，GarageBand也还没弄明白，终究和他们玩音乐的比不了啊。 旅游相册团体程序设计天梯赛 2019.03.30 中国石油大学（华东） 山东大学（威海）第六届大学生ACM程序设计竞赛 2019.04.13 威海市第四届大学生ACM程序设计竞赛 2019.04.20 北京交通大学（威海） 第十届山东省大学生ACM程序设计竞赛 2019.05.11-12 济南大学]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>大一总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F13%2FHello-World%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博文入坑Github，成功搭建Hexo博客！在此要感谢hwr dalao]]></content>
      <categories>
        <category>Daily</category>
      </categories>
  </entry>
</search>
